# Linux命令行大全
[TOC]
## 目录
第一部分 学习shell(ch1-ch10)  
第二部分 配置与环境(ch11-ch13)  
第三部分 常见任务和主要工具(ch14-ch23)  
第四部分 编写shell脚本  

## CH1 shell是什么
默认情况下，存储最近输入的500个命令  
紧按鼠标左键并拖动选中文本，该文本将被复制到由X维护的一个缓冲区，按下鼠标中间可以粘贴。不要使用`ctrl`+`c`与`ctrl`+`v`  
焦点跟随鼠标的焦点策略使终端窗口使用起来更容易  
**几个简单的命令**  
* `date` 显示当前系统的时间和日期  
* `cal` 显示当月的日历  
* `df` 查看磁盘驱动器当前的可用空间  
* `free` 显示可用内存  

## CH2 导航
在windows系统中，每个存储设备都有一个独立的文件系统树，而在类UNIX系统中，如Linux，无论多少存储设备与计算机相连，通常只有一个文件系统树  
路径名分为两种：绝对路径名和相对路径名  
以`.`字符开头的文件名是隐藏的  
与UNIX一样，在Linux中，文件名与命令是区分大小写的  
Linux没有文件拓展名的概念  
创建文件名时，仅句号，连字符和下划线是可用的  
**几个命令**：
* `pwd` 显示当前工作目录  
* `ls` 列出当前工作目录的文件和目录  
* `cd` 改变工作目录  

**cd快捷方式**
* `cd` 将工作目录改变为主目录
* `cd -` 将工作目录改变成先前的工作目录
* `cd ~username` 将工作目录改变为username的主目录

## CH3 Linux系统
**几个命令**：
* `ls` 列出目录内容
* `file` 确定文件类型
* `less` 查看文件内容  

`ls` 可以指定多个目录 `ls ~ /usr`  
通常，命令后面跟有一个或多个参数(命令作用的对象) `command -options arguments`  
大部分命令是用的选项是在单个字符前加上连字符，如`-l`。但是很多命令也支持在单字前加两个字符串的长选项。很多命令也允许多个短选项串在一起使用 `ls -lt --reverse`  
**`ls`常用的选项**
* `-a` `--all` 列出所有文件，包括以点号开头的文件
* `-d` `--directory` 通常，指定一个目录，`ls`会列出目录中的内容，而不是目录本身。与`-l`结合使用可以查看目录的详细信息
* `-F` `--classify` 在列出的名字后加上类型提示符  
* `-h` `--human-readable` 以长格式列出，以人类可读的方法显示文件大小
* `-l` 使用长格式显示结果
* `-r` `--reverse` 以相反的顺序显示结果
* `-S` 按照文件大小对结果排序
* `-t` 按照修改时间排序

**长列表格式**  
* `-rw-r--r-- 1 root root 32059 2012-04-03 11:05 00-cd-cover.odf`
* 第一部分 `-rw-r--r--` 对文件的访问权限，第一个字符是文件类型，`d`是目录，`-`是普通文件；紧跟的三个字符表示文件所有者的访问权限；再三个表示文件所属组中成员的访问权限。
* 第二部分 `1` 文件硬链接数目
* 第三部分 `root` 文件所有者的用户名
* 第四部分 `root ` 文件所有者的组名
* 第五部分 `23059` 文件的大小
* 第六部分 `2012-04-03 11:05` 上次修改时间，日期
* 第七部分 `00-cd-cover.odf` 文件名

**文本文件**：为什么要查看文本文件？因为包含系统设置的多数文件（即配置文件）是以这种格式存储的，阅读这些文件有助于更好地理解系统是如何工作的。此外，系统使用的许多实际程序（称之为脚本）也是以这种格式存储的  
**`less`常用的命令**
* `Page Up` 或 `b` 后翻一页
* `Page Down` 或 `Space` 前翻一页
* $\uparrow$ 向上一行
* $\downarrow$ 向下一行
* `G` 或 `>` 跳到文件末尾
* `g` 或 `<` 跳到文件开头
* /characters 向前查找指定的字符串
* ?characters 向后查找指定的字符串
* `n` 重复之前的查找
* `N` 重复之前的查找(反向)
* `h` 显示帮助
* `q` 退出

**符号链接**:又叫软链接，符号链接有自己的名字，但又可以指向不同的对象，类似于快捷方式。  

## CH4 操作文件与目录
**本章命令**：
* `cp` 复制文件和目录
* `mv` 移动或重命名文件和目录
* `mkdir` 创建目录
* `rm` 移除文件和目录
* `ln` 创建硬链接和符号链接

**通配符**：
* `*` 匹配任意多个字符(0个,1个,2个...)
* `?` 匹配任一单个字符(不包含0个)
* `[characters]` 匹配任意一个属于字符集中的字符
* `[!characters]` 匹配任意一个不属于字符集中的字符
* `[[:class:]]` 匹配任意一个属于指定字符类中的字符
	* `[:alnum:]` 匹配任意一个字母或者数字
	* `[:alpha:]` 匹配任意一个字母
	* `[:digit:]` 匹配任意一个数字
	* `[:lower:]` 匹配任意一个小写字母
	* `[:upper:]` 匹配任意一个大写字母

**`mkdir`** 格式 `mkdir directory ...`  
**`cp`** 格式1 `cp item1 item2` 格式2 `cp item ... direcotry`  
**`cp`命令选项**:  
* `-a` `--archive` 复制文件和目录及其属性，包括所有权和权限
* `-i` `--interactive` 覆盖前提示
* `-r` `--recursive` 递归地复制目录及其内容
* `-u` `--update` 只复制不存在或新的文件
* `-v` `--verbose` 显示信息性消息

**`mv`** 格式1 `mv item1 item2` 格式2 `mv item ... directory` 命令选项与`cp`类似  
**`rm`** 格式 `rm item ...` 当`rm`命令与通配符一起使用时，先用`ls`做测试，最后替换`ls`为`rm`  
**`rm`命令选项**：
* `-f` `--force` 忽略不存在的文件并无需提示确认
* `-i` `--interactive` 删除一个已存在的文件前，提示用户确认
* `-r` `--recursive` 递归地删除目录
* `-v` `--verbose` 显示消息

**`ln`** 创建硬链接 `ln file link` 创建软链接(符号链接) `ln -s item link` `item`既可以是文件，也可以是目录  
**硬链接**:硬链接和文件没什么区别，当硬链接被删除时，只是删除了这个链接，文件本身的内容依然存在，除非所有的链接都被删除了。硬链接有两个重要的局限性：$\bullet$ 不能引用自身文件系统之外的文件 $\bullet$ 不能引用目录  
**符号链接**:符号链接的使用和文件没什么区别，删除时，不影响原文件，但如果文件先于符号链接被删除，链接不会消失，会称为坏链接  
使用`ls -i`来查看文件的索引节点来判断硬链接  

## CH5 命令的使用
**本章命令**
* `type` 说明如何解释命令名
* `which` 显示会执行哪些可执行程序
* `man` 显示命令的手册页
* `apropos` 显示一系列合适的命令
* `info` 显示命令的info条目
* `whatis` 显示一条命令的简述
* `alias` 创建一条命令的别名

**命令的四种情况**
* 可执行程序
* shell内置命令
* shell函数
* alias命令

**`type`**
* 格式 `type command` 显示命令的类型

**`which`**
* 格式 `which command` 该命令只适用于可执行程序，而不适用于内置命令和命令别名

**`help`**
* 格式 `help command` 或 `command --help` 用于获取帮助

**`man`**
* 格式 `man program` 显示程序的手册页（一般是正式文档）
* 手册文档的组织结构
	* `1` 用户命令
	* `2` 内核系统调用的程序接口
	* `3` C库函数程序接口
	* `4` 特殊文件，如设备节点和驱动程序
	* `5` 文件格式
	* `6` 游戏与娱乐，例如屏幕保护程序
	* `7` 其他杂项
	* `8` 系统管理
	* `man 1 passwd` 显示命令`passwd`的文档
	* `man 5 passwd` 显示文件`/etc/passwd`的文件格式描述手册

**`apropos`**
* 格式 `apropos text` 搜索参考手册列表

**`whatis`**
* 格式 `whatis command` 显示匹配具体关键字的手册页的名字和一行描述

**`info`**
* 输入`info`以及程序名(可选的)来调用`info`
* GNU项目提供info页面来替代手册文档
* `info`命令选项
	* `H` 打开帮助窗口
	* `Page Up` 或 `Backspace` 返回上一页
	* `Page Down` 或 `Space` 下一页
	* `n` 显示下一个节点
	* `p` 显示上一个节点
	* `u` 显示父节点
	* `Enter` 进入光标所指的超链接
	* `q` 退出

**`alias`**
* 格式 `alias name = 'string'` 创建一条新命令，字符串中的内容将赋值给`name`，使用前最好使用`type`来检查名称是否已被使用过
* 删除别名 `unalias name`
* 使用不带参数的`alias`命令查看所有别名
* 命令行界面定义的别名，会随着shell会话结束而消失

**其他**:
* 很多软件包都有自己的文档文件，它们存放在`/usr/share/doc`目录下
* 通过使用分号来分割多条命令，就可以将多条命令输入在一行中。

## CH6 重定向
**本章命令**
* `cat` 合并文本
* `sort` 对文本行排序
* `uniq` 报告或删除文件中重复的行
* `wc` 打印文件中的换行符、字和字节的个数
* `grep` 打印匹配行
* `head` 输出文件的第一部分内容
* `tail` 输出文件的最后一部分内容
* `tee` 读取标准输入的数据，并将其内容输出到标准输出的文件中

**标准输入、输出、错误**
* 标准输出重定向 `>` `>>`(添加在尾部)
* 标准错误重定向 `2>`
* 标准输出、标准错误重定向到同一文件 `&>`
* 特殊文件(垃圾桶、黑洞) 位桶：它接受输入但不对输入进行任何处理。可以将不想要的输出重定向至此文件 `/dev/null` 例如 `ls -l /bin/usr 2> /dev/null`
* 标准输入重定向 `<`

**管道**
* 使用管道`|`可以把一个命令的标准输出传送到另一个命令的标准输入中
* `sort` 将输入行排序后输出
* `uniq` 已排好序的内容去重复，加入`-d`只保留重复
* `wc` 打印行数、单词数、字节数
* `grep` 打印匹配行 `-i`忽略大小写 `-v`输出不匹配的行
* `head` 输出文件前10行 `-n`来调整行数 例如`head -n 3 file.txt`
* `tail` 输出文件后10行
* `tee` T型管，分流

## CH7 透过shell看世界
**扩展**
* 每次输入命令行按下`Enter`键时，bash都会在执行命令之前对文本进行多重处理，一般称之为扩展
* 路径名拓展
	* 通过使用通配符来实现扩展的机制
* 波浪线拓展
	* 波浪线被扩展为指定用户的主目录名
* 算术拓展
	* 例如 `echo $((2+2))`
	* `$((expression))` 只支持整数
	* 支持 `+` `-` `*` `/` `%` `**` 可嵌套使用
* 花括号扩展
	* 例如 `echo Number_{1..5}` `echo A{1,2}`
	* 要有前导字符，支持嵌套，常用于创建一系列的文件
* 参数扩展
	* 使用变量的感觉，例如 `echo $USER`
* 命令扩展
	* 把一个命令的输出作为扩展模式使用

**引用**
* 用来有选择性的避免不想要的扩展 例如 `echo $100` 显示的结果为 `00`
* 双引号
	* 除`$` `\` `'`之外，其余特殊字符无意义
* 单引号
	* 抑制了所有的扩展
* 转义字符
	* 用来有选择性的抑制扩展

## CH8 高级键盘技巧
**本章命令**
* `clear`清屏
* `history` 显示历史列表的记录

**编辑命令行**
* 有些组合键，可能会被GUI识别为其他功能
* 光标移动
	* `ctrl`+`a` 移动光标到行首
	* `ctrl`+`e` 移动光标到行尾
	* `ctrl`+`f` 光标向前移动一个字符
	* `ctrl`+`b` 光标向后移动一个字符
	* `alt`+`f` 光标向前移动一个字
	* `alt`+`b` 光标向后移动一个字
	* `ctrl`+`l` 清屏并将光标移动到左上角
* 修改文本
	* `ctrl`+`d` 删除光标处的字符
	* `ctrl`+`t` 使光标处的字符和它前面的字符调换位置
	* `alt`+`t` 使光标处的字和它前面的字对调位置
	* `alt`+`l` 把从光标到字尾的字符转换为小写字母形式
	* `alt`+`u` 把从光标到字尾的字符转换为大写字母形式
* 剪切和粘贴文本
	* `ctrl`+`k` 剪切从光标到行尾的文本
	* `ctrl`+`u` 剪切从光标到行首的文本
	* `alt`+`d` 剪切从光标到当前词尾的文本
	* `alt`+`Backspace` 剪切从光标到词头的文本
	* `ctrl`+`y` 把kill-ring缓冲区中的文本粘贴到光标位置
* 自动补齐
	* `alt`+`$` 显示所有可能的自动补齐列表
	* `alt`+`*` 插入所有可能的匹配项
* 历史命令
	* `history` 显示历史记录
	* `ctrl`+`p` 移动到前一个命令 $\uparrow$
	* `ctrl`+`n` 移动到后一个命令 $\downarrow$
	* `alt`+`<` 移动到历史记录列表的开始处
	* `alt`+`>` 移动到历史记录列表的结尾处，即当前命令行
	* `ctrl`+`r` 逆向递增搜索 `ctrl`+`j`将搜索结果复制到当前行，`enter`直接执行
	* `alt`+`p` 逆向非递增搜索
	* `alt`+`n` 向前非递增搜索
	* `ctrl`+`o` 执行历史记录中的当前项，执行完跳到下一项
	* `!!` 重复执行最后一个执行的命令
	* `!number` 重复历史记录中第number行的命令
	* `!string` 重复最近的以string开头的历史记录
	* `!?string` 重复最近的包含string的历史记录

## CH9 权限
**本章命令**
* `id` 显示用户身份标识
* `chmod` 更改文件的模式
* `umask` 设置文件的默认权限
* `su` 以另一个用户的身份运行shell
* `sudo` 以另一个用户的身份来执行命令
* `chown` 更改文件所有者
* `chgrp` 更改文件所属群组
* `passwd` 更改用户密码

**文件权限**
* `-rwxrw-r--`
* `-` 文件类型
* `rwx` 所有者权限
* `rw-` 组权限
* `r--` 其他用户权限

**`chmod`**
* 八进制数字表示法 rwx -> 111 -> 7 例如 `chmod 600 foo.txt`
* 符号表示法 `u`所有者 `g`组 `o`其他 `a`all 例如 `chmod go+rw foo.txt`

**`umask`**
* 默认为0002或0022

**`su`与`sudo`**
* 格式 `su [-[l]] [user]` `su -c 'command'` `sudo command`
* `su`命令与`sudo`命令之间的一个重要区别在于`sudo`命令并不需要启动一个新的shell环境，而且也不需要加载另一个用户的运行环境

**`chown`**
* `chown [ower][:[group]] file ...`

**`chgrp`**
* 早期不能同时更改用户和组而引入的

**`passwd`**
* 格式 `passwd [usr]`

## CH10 进程
**本章命令**
* `ps` 显示当前所有进程的运行情况
* `top` 实时显示当时所有任务的资源占用情况
* `jobs` 列出所有活动作业的状态信息
* `bg` 设置在后台中运行作业
* `fg` 设置在前台中运行作业
* `kill` 发送信号给某个进程
* `killall` 杀死指定名字的进程
* `shutdown` 关机或重启系统

**进程**
* 使用`ps`命令查看进程信息，添加`x`选项（没有前置连字符）查看所有进程的列表信息，添加aux（不带前置连字符）将输出更多的信息
* 进程状态(STAT)
	* `R` 运行状态
	* `S` 睡眠状态
	* `D` 不可中断的睡眠状态
	* `T` 暂停状态
	* `Z` 无效或僵尸进程
	* `<` 高优先级进程
	* `~` 低优先级进程
* 在命令后面加上`&`来实现让程序后台运行，后台运行的进程不受键盘操作影响，包括`ctrl`+`c`
* 在`fg`命令后面加上百分号和作业编号，使进程返回前台来运行
* `ctrl`+`z` 会暂停进程
* `bg %1` 让程序在后台运行
* `fg %1` 让程序在前台运行
* `jobs` 查看编号

**`top`**
* 输`h`显示程序的帮助界面
* 用`q`来退出`top`指令

**`kill`**
* 格式 `kill [-signal] PID ...` 如果无指定信号，默认发送 TERM(终止) 信号  
* 常用信号
	* `1` HUP 挂起信号
	* `2` INT 中断信号
	* `9` KILL 杀死信号(最后手段)
	* `15` TERM 终止信号
	* `18` CONF 继续运行信号
	* `19` STOP 暂停信号
	* 更多符号 使用 `kill -l`

**`killall`**
* 格式 `killall [-u user] [-signal] name ...`

**其他与进程相关的命令**
* `pstree` 树状输出进程列表
* `vmstat` 系统资源使用情况的快照
* `xload` 一种图形界面程序
* `tload` 终端上绘制，内容同上

## CH11 环境
**本章命令**
* `printenv` 打印部分或全部的环境信息
* `set` 设置shell选项
* `export` 将环境导出到随后要运行的环境中
* `alias` 为命令创建一个别名

**环境**
* shell分为基本数据和编程数据
	* 基本数据包含环境变量与shell变量
	* 编程数据包含别名与shell函数

**检查环境**
* `set` 命令同时显示shell变量和环境变量
* `printenv` 命令只会显示环境变量
* `alias` 命令查看别名

**环境的建立**
* login shell（一般是远程登录，需要输入用户名与密码的情况）
	* 读取`/etc/profile`文件
	* 读取`~/.bash_profile`或`.bash_login`或`.profile`
* non-login shell (一般指图形界面启动了终端)
	* 读取`/etc/bash.bashrc`
	* 读取`~/.bashrc`

**修改**
* 先备份 `cp .bashrc .bashrc.old`
* 激活修改时，可以重新启动shell，或者`source .bashrc`
* 修改时添加注释(人类的记忆力很不靠谱)

## CH12 VI简介
**启动和退出VI**
* `vi`或`vim`启动的都是vim (好像现有的大部分版本都是这样)
* `:q`退出 加`!`强制退出

**编辑模式**
* `i` 进入插入模式
* `:w` 保存工作

**移动光标**
* `h` `j` `k` `l` 对应左下上右四个方向键
* `0` 至本行开头
* `^` 至本行第一个非空字符 (`Shift`+`6`)
* `$` 至本行末尾 (`Shift`+`4`)
* `w` 至下一单词或标点的开头
* `W` 至下一单词的开头，忽略标点 (`Shift`+`w`)
* `b` 至上一单词或标点的开头
* `B` 至上一单词的开头，忽略标点 (`Shift`+`b`)
* `ctrl`+`f`或`PageDown` 下翻一页
* `ctrl`+`b`或`PageUp` 上翻一页
* `number`-`shift`-`G` 至第`number`行
* `G` 至文件的最后一行 (`Shift`+`g`)
* 许多命令前，都可以加数字，如 `5j` 光标下移五行

**基本编辑**
* 添加文本
	* `a` 光标后移一位并进入插入模式
	* `A` 光标移动到行末并进入插入模式
* 插入一行
	* `o` (小写) 在当前行的下方插入一行
	* `O` (大写) 在当前行的上方插入一行
* 删除文本
	* `x` 删除当前字符
	* `3x` 删除当前字符和之后的两个字符
	* `dd` 删除当前行
	* `5dd` 删除当前行和之后四行
	* `dw` 删除当前字符到下一单词的起始
	* `d$` 删除当前字符到当前行的末尾
	* `d0` 删除当前字符到当前行的起始
	* `d^` 删除当前字符到当前行下一个非空字符
	* `dG` 删除当前行到文件末尾
	* `d20G` 删除当前行到第20行
* 剪切、复制与粘贴
	* `d` 剪切
	* `y` 复制
	* `p` 粘贴
	* `y` 命令与 `d`命令几乎相同
	* `p` 粘贴到当前行上方 `P` 粘贴到当前行下方
* 合并行
	* `J` 合并当前行与下一行

**查找和替换**
* 行内搜索 (一个字符)
	* `f`+一个字符 输入`;`重复上一次搜索
* 搜索整个文件
	* `/`+单词或短语 输入`n`重复此搜索
* 全局搜索和替换
	* 例如 `:%s/Line/line/g`
	* `:`启动ex命令
	* `%`作用范围
	* `s`具体操作
	* `/搜索/替换`
	* `g` 代指全局

**编辑多个文件**
* 同时打开多个文件的情况下可以使用`:n`与`:N`切换到下/上一个文件
* 多文件之间也可以进行内容复制
* `:buffers` 查看文件列表
* `:buffer 2` 切换到文件2
* `:e foo.txt` 添加文件到编辑会话中
* `:r foo.txt` 将指定的文件内容插入到光标所在行的下一行
* `:w` 保存文件
* `:w file-name` 另存为文件（不过编辑的仍是当前文件）

## CH13 定制提示符
* 提示符是由名为PS1的环境变量定义的

**shell提示符中使用的转义字符**
* `\a` ASCII铃声
* `\d` 当前日期，以星期、月、日的形式表示
* `\h` 本地机器的主机名，但是不带域名
* `\H` 完整的主机名
* `\j` 当前shell会话中进行的任务个数
* `\l` 当前终端设备的名称
* `\n` 换行符
* `\r` 回车符
* `\s` shell程序的名称
* `\t` 当前时间(24小时制) 格式为小时:分钟:秒
* `\T` 当前时间(12小时制)
* `\@` 当前时间(12小时制) 格式为AM/PM
* `\A` 当前时间(24小时制) 格式为小时:分钟
* `\u` 当前用户的用户名
* `\v` shell的版本号
* `\V` shell的版本号和发行号
* `\w` 当前工作目录名
* `\W` 当前工作目录名称的最后一部分
* `\!` 当前命令的历史编号
* `\#` 当前shell会话中输入的命令数
* `\$` 在非管理员权限下输出$，在管理员权限下输出#
* `\[` 标志一个或多个非打印字符序列的开始。用于嵌入非打印的控制字符，使其以一定方式操纵终端仿真器，比如移动光标或更改文本颜色
* `\]` 标志着非显示字符序列的结束

**设置文本颜色的转义序列**
* `\033[0;30m` 黑色
* `\033[0:31m` 红色
* `\033[0:32m` 绿色
* `\033[0:33m` 棕色
* `\033[0:34m` 蓝色
* `\033[0:35m` 紫色
* `\033[0:36m` 青色
* `\033[0:37m` 淡灰色
* `\033[1;30m` 深灰色
* `\033[1:31m` 淡红色
* `\033[1:32m` 淡绿色
* `\033[1:33m` 黄色
* `\033[1:34m` 淡蓝色
* `\033[1:35m` 淡紫色
* `\033[1:36m` 淡青色
* `\033[1:37m` 白色
* `\033[0m` 默认颜色
* 文本除了正常(0)和粗体(1)属性外，还可以设置为下划线(4)、闪烁(5)和斜体(7)

**设置背景颜色的转义序列**
* `\033[0;40m` 黑色
* `\033[0:41m` 红色
* `\033[0:42m` 绿色
* `\033[0:43m` 棕色
* `\033[0:44m` 蓝色
* `\033[0:45m` 紫色
* `\033[0:46m` 青色
* `\033[0:47m` 淡灰色

**光标移动转义序列**
* `\033[1;cH` 将光标移动至1行c列
* `\033[nA` 将光标向上移动n行
* `\033[nB` 将光标向下移动n行
* `\033[nC` 将光标向前移动n个字符
* `\033[nD` 将光标向后移动n个字符
* `\033[2J` 清空屏幕并将光标移动至左上角(0行0列)
* `\033[K` 清空当前光标位置到行末的呃逆荣
* `\033[s` 储存当前光标位置
* `\033[u` 恢复之前存储的光标位置

## CH14 软件包管理
**两种软件包技术阵营**
* Debian类 (`.deb`技术)
* Red Hat类 (`.rpm`技术)、

**软件包系统工具**
* Debian类 低级工具 `dpkg` 高级工具 `apt-get` `aptitude`
* Red Hat、Centos 低级工具 `rpm` 高级工具 `yum`

**常见软件包管理任务**
* 在库里面查找软件包
	* Debian `apt-get update` `apt-get search search_string`
	* Red Hat `yum search search_string`
* 安装库中的软件包
	* Debian `apt-get update` `apt-get install package_name`
	* Red Hat `yum install package_name`
* 安装软件包文件中的软件包
	* Debian `dpkg --install package_file`
	* Red Hat `rpm -i package_file`
	* 这种情况下，不会解决依赖性关系
* 删除软件包
	* Debian `apt-get remove package_name`
	* Red Hat `yum erase package_name`
* 更新库中的软件包
	* Debian `apt-get update` `apt-get upgrade`
	* Red Hat `yum update`
* 更新软件包文件中的软件包
	* Debian `dpkg --install package_file`
	* Red Hat `rpm -U package_file`
* 列出已安装的软件包列表
	* Debina `dpkg --list`
	* Red Hat `rpm -qa`
* 判断软件包是否安装
	* Debian `dpkg --status package_name`
	* Red Hat `rpm -q package_name`
* 显示已安装软件包的相关信息
	* Debian `apt_cache show package_name`
	* Red Hat `yum info package_name`
* 查看某具体文件是由哪个软件包安装得到的
	* Debian `dpkg --search file_name`
	* Red Hat `rpm -qf file_name`

## CH15 存储介质
**本章命令**
* `mount` 挂载文件系统
* `unmount` 卸载文件系统
* `fdisk` 硬盘分区命令
* `fsck` 检查修复文件系统
* `fdformat` 格式化软盘
* `mkf` 创建文件系统
* `dd` 向设备直接写入面向块数据
* `genisoimage`(`mkisofs`) 创建一个ISO9600映像文件
* `wodim`(`cdrecord`) 向光存储介质写入数据
* `md5sum` 计算md5校验码
* `/etc/fstab` 文件内容列出了系统启动时挂载的设备

**挂载、卸载存储设备**
* `mount` 调出目前已经挂载的文件系统列表
* `umount /dev/sdb1` 卸载设备
* `mount /dev/sdb1 ./dev` 挂载到新的节点

**创建新的文件系统**
* `sudo umount /dev/sdb1` 先卸载设备
* `sudo fdisk /dev/sdb` 启动fdisk程序进行磁盘分区
	* `m` 显示菜单
	* `l` 显示有效分区类型对照表
	* `n` 新建分区
	* `t` 修改分区类型 
	* `w` 保存并退出
* `sudo mkfs -t ext4 /dev/sdb1` 创建新的文件系统
* `sudo mkfs -t vfat /dev/sdb1`

**测试、修复文件系统**
* 检查闪存(闪存事先应该已卸载) `sudo fsck /dev/sdb1`

**直接从/向设备转移数据**
* `dd` 命令将数据块从一个地方复制到另一个地方
* `dd` 格式 `dd if=input_file of=output_file [bs=block_size [count=blocks]]`
* 例如 `dd if=/dev/sdb of=/dev/sdc` `dd if=/dev/sdb of=flash_drive.img`

## CH16 网络
**本章命令**
* `ping` 向目标主机发送ICMP ECHO_REQUEST数据包
* `traceroute` 显示数据包到网络主机的路由路径
* `netstat` 显示网络连接、路由表、网络接口数据、伪连接以及多点传送成员等信息
* `ftp` 文件传输命令
* `lftp` 改善后的文件传输命令
* `wget` 非交互式网络下载器
* `ssh` openSSH版的SSH客户端
* `scp` secure copy 的缩写，是远程复制文件命令
* `sftp` 安全文件传输程序

**检查、监测网络**
* 例如 `ping baidu.com` `traceroute baidu.com`
* 使用`-ie`选项，可以查看系统中的网络接口信息
* `netstat -ie`
* 使用`-r`选项将显示内核网络路由表

**通过网络传输文件**
* `ftp`
* `lftp`
* `wget baidu.com/index.html`

**与远程主机的安全通信**
* `ssh root@xxx.com` 安全登陆
* 网络间文件复制
	* `scp root@xxx.com:file_name ./`
	* `sftp root@xxx.com`
		* `ls`
		* `get file-name`
		* `bye`

## CH17 文件搜索
**本章命令**
* `locate` 通过文件名查找文件
* `find` 在文件系统目录框架中查找文件
* `xargs` 从标准输入中建立、执行命令行
* `touch` 更改文件的日期时间
* `stat` 显示文件或文件系统的状态

**`locate`较简单的方式查找文件**
* `locate`命令通过快速搜索数据库，以寻找路径名与给定子字符串相匹配的文件，同时输出所有匹配结果，例如 `locate bin/zip`
* 可以使用`locate`命令结合其他诸如`grep`这样的工具实现一些更有趣的搜索，例如 `locate zip | grep bin`
* `locate`的搜索数据库是由名为`updatedb`的程序定期创建的。

**`find`较复杂的方式查找文件**
* `find`程序是依据文件的各种属性在既定的目录(及其子目录)中查找
* `find ~` 列出`~`下的文件列表清单
* `find ~ | wc -l` 计算列出的文件总量
* `find` 命令综合应用`test`选项、`action`选项以及`options`选项实现高级文件搜索

**`test`选项**
* 例如想要查找目录文件 `find ~ -type d | wc -l`
* 例如想要查找所有符合`*.jpg`通配符格式以及大小超过`1MB`的普通文件 `find ~ -type f -name "*.jpg" -size +1M | wc -l`
* `find`支持搜索的文件类型
	* `b` 块设备文件
	* `c` 字符设备文件
	* `d` 目录
	* `f` 普通文件
	* `l` 符号链接
* `find`支持的计量单位
	* `b` 512字节的块
	* `c` 字节
	* `w` 两个字节的字
	* `k` KB(1024字节)
	* `M` MB(1048576字节)
	* `G` GB(1073741824字节)
	* `+` 表示大 `-` 表示小 不添加任何符号表示完全相等
* `find`命令的`test`项参数(常见)
	* `-cmin n` 匹配n分钟前改变状态(内容或属性)的文件或目录。 `+n`表示超过 `-n`表示不足
	* `-cnewer file` 匹配内容或属性的修改时间比文件file更晚的文件或目录
	* `-ctime n` 匹配系统中n$\times$24小时前文件状态被改变的文件或目录
	* `-empty` 匹配空目录及空文件夹
	* `-group name` 匹配属于name组的文件或目录，name可以为组名或者组id
	* `-iname pattern` 与`-name test`项功能类似只是不区分大小写
	* `-inum n` 匹配索引节点是n的文件。该test选项有助于查找某个特定索引节点上的所有硬链接
	* `-mmin n` 匹配n分钟前内容被修改的文件或目录
	* `-mtim n` 匹配n$\times$24小时前只有内容被修改的文件或目录
	* `-name pattern` 匹配有特定通配符模式的文件或目录
	* `-newer file` 匹配内容的修改时间比file更近的文件或目录
	* `-nouser` 匹配不属于有效用户的文件或目录
	* `-nogroup` 匹配不属于有效组的文件或目录
	* `-perm mode` 寻找访问权限与既定模式匹配的文件或目录，既定模式可以以八进制或符号的形式表示
	* `-samefile name` 与`inum test`选项类似，匹配与file文件用相同的inode号的文件
	* `-size n` 匹配n大小的文件
	* `-type c` 匹配c类型的文件
	* `-user name` 匹配name用户的文件和目录、用户名或id
* `find`命令的逻辑操作符
	* `-and` 与操作
	* `-or` 或操作
	* `-not` 非操作
	* `()` 优先级控制(带反斜杠)
	* 例如 `find ~ \(-type f -not -perm 0600 \)`
	* `-and`左侧为假，右侧不执行 `-or`左侧为真，右侧不执行

**`action`选项**
* 预定义的`find`命令操作
	* `-delete` 删除匹配文件
	* `-ls` 对文件执行`ls`操作
	* `-print` 将匹配的文件的全路径以标准形式输出
	* `-quit` 一旦匹配成功则退出
* 调用用户想要执行的操作命令，传统的方法是使用`-exec`操作
	* `-exec command {};`
	* 例如 `-exec rm '{}' ';'` 删除操作(因为花括号与分号有特殊意义，所以要用引号)
	* 其中`{}`代表当前路径，分号作为必须的分隔符表示命令结束
* 提高效率
	* 如将`ls file1; ls file2; ls file3;`这种多次重复执行的命令改为执行一次的命令`ls file1 file2 file3`，有两种方法，$\bullet$使用`find`本身自带的新特性 $\bullet$使用外部命令`xargs`(传统)
	* 通过将命令行末尾的分号改为加号，便可将`find`命令所搜索到的匹配结果作为指定命令的输入，从而一次完成对所有文件的操作 例如 `find ~ -type f -name 'foo*' -exec ls -l '{}' +`
	* `xargs`处理标准输入信息并将其转变为某指定命令的输入参数列表 例如 `find ~ -name 'foo*' -print | xargs ls -l`
	* `find`命令提供`-print0`这`action`选项来产生以空字符(\0)作为参数分割的结果，而`xargs`命令则有`--null`参数选项支持接收以空字符为分隔符的输入(PS:空格为\32) 例如 `find ~ -iname '*.jpg' -print0 | xargs --null ls -l`

**`option`选项**
* `-depth` 引导`find`程序处理目录前先处理目录内文件
* `-maxdepth levels` 当执行测试条件行为时，设置`find`程序陷入目录数的最大级别数
* `-mindepth levels` 在应用测试条件和行为之前，设置`find`程序陷入目录数的最小级别数
* `-mount` 引导`find`不去遍历挂载在其他文件系统上的目录
* `-noleaf` 指导`find`程序不要基于"正在搜索类UNIX文件系统"的假设来优化它的搜索

## CH18 归档和备份
**常用命令**
* 文件压缩程序
	* `gzip` 压缩和解压缩文件工具
	* `bzip2` 块排序文件压缩工具
* 文件归档程序
	* `tar` 磁带归档工具
	* `zip` 打包和压缩文件
* 文件同步程序
	* `rsync` 远程文件和目录的同步

**`gzip`**
* `gzip`命令用于压缩一个或多个文件，`gunzip`命令则将压缩的文件还原回原文件 如 `gzip foo.txt` `gunzip foo.txt`(默认为'.gz'的文件)
* `gzip`的选项
	* `-c` 将输出内容写到标准输出端口并且保持原有文件
	* `-d` 解压缩，加上此选项，`gzip`类似于`gunzip`
	* `-f` 强制压缩，即使原文件的压缩版本已经存在
	* `-h` 显示有用信息，等于`--help`
	* `-l` 列出所有压缩文件的压缩统计，等于`--list`
	* `-r` 如果参数有目录，则递归压缩包含在目录中的文件
	* `-t` 检验压缩文件的完整性 `--test`
	* `-v` 在压缩时显示详细信息 `--verbose`
	* `-number` 设定压缩级别 1(速度最快)~9(压缩比最大) 默认为6

**`bzip2`**
* 牺牲速度以换取高质量的压缩，以`bz2`为后缀
* `gzip`的所有选项(除了`-r`) `bzip2`都支持

**`tar`**
* `tar`命令的操作模式(详见`--help`)
	* `c` 创建文件和/或目录列表的归档文件
	* `x` 从归档文件中提取文件
	* `t` 在归档文件末尾追加指定路径名
	* `r` 列出归档文件的内容
* `tar`命令的用法如下
	* `tar mode[options] pathname ...`
	* 例如 `tar cf playground.tar playground` 创建归档文件 `tar xf playground.tar`提取到当前目录
* `tar`默认路径名是相对路径
* 希望从归档文件中只提取单个文件 `tar xf archive.tar pathname`
* `tar`与`find`共同使用实例 `find playground -name 'file-A' exec tar rf playground.tar '{}' '+'`
* `tar`命令利用标准输入输出实例 `find playground -name 'file-A' | tar cf - --files-from=- | gzip > playground.tgz`

**`zip`**
* Linux系统中，`gzip`才是主要的压缩指令，而`bzip2`仅次之，Linux用户主要使用`zip`程序与Windows系统交换文件
* `zip`最基本的调用方式如下 `zip options zipfile file ...` 例如 `zip -r playground.zip playground`
* 利用`unzip`提取`zip`文件中的内容，更多内容参考`man`手册

**`rsync`**
* 命令调用方式如下 `rsync options srouce destination`
* 例如 `sudo rsync -av --delete /etc /home /usr/local /media/BigDisk/backup` `sudo rsync --av --delete --rsh=ssh /etc /home /usr/local remote-sys:/backup`

## CH19 正则表达式
**`grep`文本搜索**
* 使用格式 `grep [options] regex [flie ...]` 其中 `regex`代表的是某个正则表达式
* `grep`选项
	* `-i` 忽略大小写 `--ignore-case`
	* `-v` 不匹配(默认输出匹配行) `--invert-match`
	* `-c` 输出匹配行数 `--count`
	* `-l` 输出匹配项文件名而不是直接输出匹配行本身 `--files-with-matches`
	* `-L` 与`-l`类似，但输出是不包含的 `--files-without-matches`
	* `-n` 在每个匹配行加上该行在文件内的行号 `--line-number`
	* `-h` 进行多文件搜索时，抑制文件名输出 `--no-filename`

**正则表达式**
* 正则表达式的元字符有
	* `^` `$` `.` `[` `]` `{` `}` `-` `?` `*` `+` `(` `)` `|` `\`
	* 其他所有字符则被当做文字字符
	* 在命令行中输入包含元字符的正则表达式时，应该把这些元字符用括号括起来以避免不必要的shell扩展
* 任意字符 `.` `grep -h '.zip' dirlist *.txt`
* 锚 插入符`^`和美元符号`$`
	* 正则表达式只与行的开头`^`或末尾`$`的内容进行比较
	* 例如 `grep -h '^zip' *.txt` 以zip开头 `grep -h 'zip$' *.txt` 以zip结尾
	* Linux自带字典 见`/usr/share/dict`
* 中括号表达式与字符类
	* 中括号用于匹配指定字符集中的单个字符，并且，当元字符防御中括号中时，会失去它们的特殊含义(特殊情况：插入符`^`在中括号内使用表示否定(第一个) 连字符`-`在中括号内表示字符范围(不是第一个))
	* POSIX字符类
		* `[:alnum:]` 字母字符和数字字符，在ASCII码中，与`[A-Za-z0-9]`等效
		* `[:word:]` 基本与`[:alnum:]`一样，只是多了下划线`_`
		* `[:alpha:]` 字母字符，在ASCII中，等效于[A-Za-z]
		* `[:blank:]` 包括空格和制表符
		* `[:cntrl:]` ASCII控制码(0~31与127)
		* `[:digit]` 数字0~9
		* `[:graph:]` 可见字符，在ASCII中，包括字符33~126
		* `[:lower:]` 小写字母
		* `[:punct:]` 标点符号字符，在ASCII中，与`[-!"#$%&'()*+,./:;<=>?@[\\\]_{|}~'"]`，还有\`符号(md语法中不好写)等效
		* `[:print:]` 可打印字符，包括`[:graph:]`中的所有字符再加上空格字符
		* `[:space:]` 空白字符如空格符、制表符、回车符、换行符、垂直制表符以及换页符，在ACSII中，等效为`[\t\r\n\v\f]`
		* `[:upper:]` 大写字母
		* `[:xdigit:]` 用于表示十六进制的字符，在ASCII中，与[0-9A-Fa-f]等效
		* 例如 `ls /usr/sbin/[[:upper:]]]*`
	* ASCII: AB...XYZab...xyz
	* 字典: aAbB...xXyYzZ

**扩展正则表达式**
* 在基本正则表达式中，只承认`^` `$` `.` `[` `]` `*`这些是元字符
* 或选项`|`可以用`()`调整优先级 如`echo "AAA" | grep -E "AAA|BBB|CCC"`
* 匹配某元素0次或1次 `?`(加在元素后)
* 匹配某元素多次或0次 `*`
* 匹配某元素1次或多次 `+`
* 指定次数匹配某元素 `{}`
	* `{n}` 恰好出现n次
	* `{n,m}` n~m次之间
	* `{n,}` 超过n次
	* `{,m}` 不超过m次

**正则表达式的应用**
* 用`grep`命令验证号码簿
* 用`find`命令查找奇怪文件名的文件
* 用`locate`查找文件
* 利用`less`和`vim`命令搜索文本

## CH20 文本处理
**本章命令**
* `cat` 连接文件并打印到标准输出
* `sort` 对文本行排序
* `uniq` 报告并省略重复行
* `cut` 从每一行中移除文本区域
* `paste` 合并文件文本行
* `join` 基于某个共享字段来联合两个文件的文本行
* `comm` 逐行比较两个已经排好序的文件
* `diff` 逐行比较文件
* `patch` 对原文件打补丁
* `tr` 删除或转换字符
* `sed` 用于过滤和转换文本的流编辑器
* `aspel` 交互式拼写检查器
* 
**`cat`**
* `-A` 选项，用于显示文本中的非打印字符 `^I` 表示Tab制表符 `$`表示行尾
* `cat` 输入时，按下`ctrl`+`d`告诉其到达文件尾
* `-n` 选项，对行编号
* `-s` 选项，禁止输出多个空白行
* UNIX以换行符(ASCII码10)作为行末尾，而DOS及其衍生系统则使用回车符(ASCII码13)和换行符共同作为行末尾

**`sort`**
* `sort`是一个排序程序，它的操作对象是标准输入或是命令行中指定的一个或多个文件。结果送至标准输出
*  常见的`sort`选项
	*  `-b` 默认情况，从第一个字符开始比较，添加该选项会忽略行首的空格
	*  `-f` 排序时不区分字符大小写
	*  `-n` 基于字符串的长度排序
	*  `-r` 你序排序
	*  `-k` 基于键排序
	*  `-m` 合并已排好序的文件
	*  `-o` 将排序结果输出到文件
	*  `-t` 定义字段分隔符。默认是空格或制表符

**`uniq`**
* 给定一个已排好序的文件后，`uniq`会删除任何重复的行并将结果输出到标准输出中
* 常见的`uniq`选项
	* `-c` 输出重复行列表，并在前面加上重复次数
	* `-d` 只输出重复行，不包括单独阿红
	* `-f n` 忽略每行前n个字段
	* `-i` 行与行之间比较时忽略大小写
	* `-s n` 跳过每行的前n个字符
	* `-u` 仅输出不重复的行

**`cut`**
* 从文本行中提取一段文字并将其输出到标准输出
* `cut`选择选项
	* `-c char_list` 从文本行中提取char_list定义的部分内容。此列表可能会包含一个或更多冒号分开的数值范围
	* `-f field_list` 从文本行中提取field_list定义的一个或多个字段。该列表可能会包含由冒号分隔开的一个、多个字段或字段范围。
	* `-d delim_char` 指定`-f`选项后，使用delim_char作为字段分界符
	* `--complement` 从文本中提取整行，除了那些由`-c`和/或`-f`指定的部分

**`paste`**
* 该命令读取多个文件，并将每个文件中提取出的字段结合为一个整体的标准输出流
* 例如 `paste di-date.txt di-version.txt`

**`join`**
* `join`是一个基于共享关键字段将多个文件的数据拼接在一起的操作

**`comm`**
* 例如 `comm file1.txt file2.txt`
* 输出三列内容，第三列是共有的
* `-n`选项(1,2,3)，可以用于省略第n列的内容

**`diff`**
* `diff`改变命令
	* `r1ar2` 将第二个文件中r2位置的行添加到第一个文件中的位置r1处
	* `r1cr2` 用第二个文件r2处的行替换第一个文件中r1处的行
	* `r1dr2` 删除第一个文件r1处的行，并且删除的内容为第二个文件r2行范围的内容
* `-c` 选项 上下文格式
* 上下文格式差异标识符
	* `(无)` 该行表示上下文文本。表示两个文件共有的行
	* `-` 缺少的行。第一个文件中有，第二个文件中没有
	* `+` 多余的行。第二个文件中有，第一个文件中没有
	* `!` 改变的行
* `-u` 选项 统一格式

**`patch`**
* `diff`/`patch` 可以只提交修改部分的内容
* 生成供`patch`使用的diff文件的建议命令格式
	* `diff -Naur old_file new_file > diff_file`
	* `patch < diff_file` 执行修改

**`tr`**
* `echo "lowercase letters" | tr a-z A-z`
* `echo "lowercase letters" | tr [:lower:] A`
* `tr -d '\r' < dos_file > unix_file`
* `-s`选项可以"挤兑"重复出现的字符
* `echo "aaabbbccc" | tr -s ab`

**`sed`**
* 流式编辑器 例如 `echo "front" | sed 's/front/back/'`
* 分界符一般常用`/`，紧跟在命令后的字段都被视为分界符 例如 `echo "front" | sed 's_front_back_'`
* `sed` 中的多数命令允许在其前添加一个地址，该地址用来指定输入流的哪一行被编辑
* `sed` 的地址表达法
	* `N` n是正整数表示行号
	* `$` 最后一行
	* `/regexp/` 用POSIX基本正则表达式描述的行
	* `first~step` 行号从first行开始，以step为间隔的所有行
	* `addr1,+n` addr1行及其之后的n行
	* `addr!` 除了addr之外的所有行
* `sed` 基本编辑指令
	* `=` 输出当前行号
	* `a` 在当前行后附加文本
	* `d` 删除当前行
	* `i` 在当前行前输入文本
	* `p` 打印当前行，通常与`-n`共同使用
	* `q` 退出`sed`不再处理其他行
	* `Q` 直接退出`sed`不再处理行
	* `s/regexp/replacement/` 将 regexp的内容替换为replacement的内容
	* `y/set1/set2` 将字符集set1转换为字符集set2
* 正则表达式的回参考特性
	* `\n` n为1~9之间的任意数字
	* `([0-9]{2})/([0-9]{2})/([0-9]{4})$ \3-\1-\2`

**`aspell`**
* 例如 `aspell check foo.txt`

## CH21 格式化输出
**本章命令**
* `nl` 对行进行标号
* `fold` 甚至文本行长度
* `fmt` 简单的文本格式化工具
* `pr` 格式化打印文本
* `printf` 格式化并打印数据
* `grof` 文档格式化系统

**`nl`**
* `nl`标记
	* `\:\:\:` 逻辑页页眉开头
	* `\:\:` 逻辑页正文开头
	* `\:` 逻辑页页脚开头
* 常用的`nl`选项
	* `-b style` 按照 style 格式对正文进行编号, style 类型如下
		* `a` 对每行编号
		* `t` 仅仅对非空白行编号(默认)
		* `n` 不对任何行进行编号
		* `pregexp` 只对与基本正则式匹配的行进行编号
	* `-f style` 以style的格式对页脚进行编号，默认是n
	* `-h style` 以style的格式对页首记性编号，默认是n
	* `-i number` 设置页编号的步进值为number，默认是1
	* `-n fromat` 设置编号格式为fromat，fromat如下
		* `ln` 左对齐，无缩进
		* `rn` 右对齐，无缩进(默认)
		* `rz` 右对齐，有缩进
	* `-P` 在每个逻辑页的开始不再进行页编码重置
	* `-s string` 在每行行号后面增加string作为分隔符，默认是tab
	* `-v number` 将每个逻辑页的第一个行号设置为number，默认是1
	* `-w width` 设置行号字段的宽度为width，默认值是6

**`fold`**
* `-w n` 指定行的宽度为n(默认80)
* `-s` 按照有效空格断开

**`fmt`**
* `fmt`选项
	* `-c` 保留前两行的缩进
	* `-p string` 只格式化以前缀字符串string
	* `-s` 仅截断长行，而不续接
	* `-u` 字符间隔统一，单词后一个空格，句子后两个空格
	* `-w width` 每行最大宽度(默认是75)

**`pr`**
* `-l` 选项确定页长
* `-w` 选项确定页宽

**`printf`**
* 用法 `printf "format" arguments`
* 常用printf数据类型指定符
	* `D` 将一个数字格式化为有符号的十进制表示形式
	* `F` 格式化数字并以浮点数的格式输出
	* `O` 将一个整数格式化为八进制格式的整数
	* `s` 格式化字符串
	* `x` 将一个整数格式化为十六进制的数，并且在使用字母时，用小写字母a~f表示
	* `X` 与x类似，只是字母用大写形式表示
	* `%` 打印文本符号`%`
* 转换格式 `%[flags][width][.presision]conversion_specification`
* flags
	* `#` 使用替代格式输出 如0.., 0x.., 0X..
	* `0` 用0填充输出
	* `-` 输出左对齐
	* ` ` 为正数产生一个前导空格
	* `+` 显示正数符号

## CH22 打印
跳过

## CH23 编译程序
* `./configure` 检查及配置
* `make` 使用makefile中的内容指导编译
* `sudo make install` 一步到位，且安装到`/usr/local/bin`下

## CH24 编写第一个shell脚本
**基本步骤**
1. 编写脚本
2. 使脚本可执行
3. 将脚本放置到shell能够发现的位置
* `#` 之后是注释，可单行，可行末
* `#!` 称之为shebang，用于告知操作系统，执行后面的脚本应使用的解释器的名字，应作为第一行
* 两种常见的权限设置
	* 755 每个人都可以执行
	* 700 脚本所有人都可以执行
* PATH变量修改 在.bashrc中增加一行`export PATH=~/bin:"$PATH"`
* 为编写脚本而配置vim参见P310

## CH25 启动一个项目
**两种通过`echo`命令输出文本的方法**
```bash
echo "first line"
echo "second line"
```
```bash
echo "first line
second line"
```

**变量和常量**
* 普遍约定，大写表示常量，小写表示变量
* `varibale=value`
* 在赋值时，变量名，等号和值之间不能含有空格
* 变量名称使用花括号括起来更明确

**`here`文档**
```bash
command << token
text
token
```
* token 必须在一行单独出现，其后没有空格
* 如果将`<<`改为`<<-` shell就会忽略在here文档中开头的tab字符

## CH26 自顶向下设计
**shell函数**
* shell 函数有两种语法形式
	```bash
	function name {
		commands
		return
	}
	```
	```bash
	name() {
		commands
		return
	}
	```
* shell函数的定义在脚本中的位置必须在它被调用的前面

**局部变量**
* 
	```bash
	funct_1() {
		local foo
		foo=1
		echo "funct_1:foo = $foo"
	}
	```
* 局部变量是通过在变量前添加`local`来定义的

## CH27 IF分支语句
**使用if**
* if语句的语法格式如下
	```bash
	if commands; then
		commands
	[elif commands; then
		commands ...]
	[else
		commands]
	fi
	```
* `commands`可以是一组命令

**退出状态**
* 命令(包括脚本和shell函数)在执行完毕后，会向操作系统发送一个值，称之为“退出状态”，0表示执行成功
* `true` 命令总是执行成功
* `false` 命令总是执行失败
* 如果在`if`后面有一系列的命令，那么则根据最后一个命令的执行结果进行评估

**使用`test`命令**
* `test`命令两种等价的形式(经常和`if`一起使用)
	```bash
	test expression
	[expression]
	```
* 测试文件的表达式
	`file -ef file2` file1和file2拥有相同的信息节点编号
	`file -nt file2` file1比file2新
	`file -ot file2` file1比file2旧
	`-b file` file存在并且是一个块(设备)文件
	`-c file` file存在并且是一个字符(设备)文件
	`-d file` file存在并且是一个目录
	`-e file` file存在
	`-f file` file存在并且是一个普通文件
	`-g file` file存在并且设置了组id
	`-G file` file存在并且属于有效组id
	`-k file` file存在并且有"粘滞位"属性
	`-L file` file存在并且是一个符号链接
	`-O file` file存在并且属于有效用户id
	`-p file` file存在并且是一个命令管道
	`-r file` file存在并且可读
	`-s file` file存在并且其长度大于0
	`-S file` file存在并且是一个网络套接字
	`-t fd` fd是一个定向到终端/从终端定向的文件描述符，可以用来确认标准输入/输出/错误是否被重定向
	`-u file` file存在并且被设置了setuid位
	`-w file` file存在并且可写
	`-x file` file存在并且可执行
* 测试字符串的表达式
	* `string` string不为空
	* `-n string` string的长度大于0
	* `-z string` string的长度等于0
	* `string1=string2` `string1==string2` string1等于string2
	* `string1!=string2` string1和string2不相等
	* `string1>string2` string1在string2之后
	* `string1<string2` string1在string2之前
* 在使用`test`命令时，`>`和`<`必须用括号括起来(或使用反斜杠进行转义)
* 整数判断操作
	* `integer1 -eq integer2` i1和i2相等
	* `i1 -ne i2` i1和i2不相等
	* `i1 -le i2` i1小于等于i2
	* `i1 -lt i2` i1小于i2
	* `i1 -ge i2` i1大于等于i2
	* `i1 -gt i2` i1大于i2

**增强的`test`命令**
* 语法 `[[expression]]`
* 增加了 `string = ~regex` 如果string与扩展的正则表达式regex相匹配，则返回true
* 增加的另一个特性是`==` 支持模式匹配 例如 `[[$FILE == foo.*]]`

**`(())`为整数设计**
* 例如 `((INT == 0))`
* 能够通过名字来识别变量

**组合表达式**
|操作|`test`|`[[]]`与`(())`|
|:---:|:---:|:---:|
|AND|`-a`|`&&`|
|OR|`-o`|`||`|
|NOT|`!`|`!`|
* 由于test使用的所有表达式和操作符都被shell看做命令参数(不像``(())`以及`[[]]`)，因此在bash中有特殊含义的字符，比如`<` `>` `(` `)` 必须用引号括起来或者进行转义

**控制运算符：另一种方式的分支**
* `c1 && c2` c1执行成功才执行c2
* `c1 || c2` c1执行失败才执行c2

## CH28 读取键盘输入
**`read`从标准输入读取输入值**
* 内嵌命令`read`的作用是读取一行标准输入
* `read`选项
	* `-a array` 将输入值从索引为0的位置开始赋给array
	* `-d delimiter` 用字符串delimiter的第一个字符标志输入结束
	* `-e` 使用Readline处理输入
	* `-n num` 从输入中读取num个字符，而不是一整行
	* `-r` 原始模式，不能将`\`字符翻译为转义码
	* `-s` 保密模式
	* `-t seconds` 超时，在seconds秒后结束输入，若输入超时，read命令返回一个非0的退出状态
	* `-u fd` 从文件说明符fd读取输入
* 若read命令读取的值少于预期的数目，则多余的变量值为空，而输入值的数目超出预期的结果时，最后的变量包含了所有的多余值
* 如果read后没有变量，则为shell变量`REPLY`

**使用IFS间隔输入字段**
* 改变IFS来控制read命令输入的建个房室
* shell允许在命令执行之前对一到多个变量进行赋值，这些操作会改变接下来所执行命令的操作环境，但是赋值效果是暂时性的，只在命令执行周期内有效
* `IFS=":" read var1 var2 var3`
* 操作符`<<<`象征一条嵌入字符串
* read不可重定向，因为管道会创造子shell `echo "foo" | read`

## CH29 WHILE和UNTIL循环
**`while`**
* 语法结构 `while commands; do commands; done`
* `break` 终止循环
* `continue` 跳过剩余部分

**`until`**
* 语法 `until commands; do commands; done`
* 判断条件为真时结束

**其他**
* 为将一份文件重定向到循环中，我们可以在done语句之后添加重定向操作符

## CH30 故障诊断
**语法错误**
* 引号缺失
* 符号缺失冗余
* 非预期的展开

**逻辑错误**
* 条件表达式错误
* "从1开始"错误
* 非预期的情形
* 建议：防御编程，每一步都进行严格的测试
* 建议：输入值验证

**测试**
* 桩(stub)
* 测试用例

**调试**
* 在脚本第一行添加`-x`选项即可激活对整个脚本的追踪活动
* 要对某一部分执行追踪，可以使用`set`命令加`-x`选项 `set`加`-x` 激活追踪 `set`加`+x`解除追踪

## CH31 流控制 case分支
**`case`**
* 语法 
	```bash
	case word in
		[pattern [|pattern]...) commands ;;]...
	esac
	```
* case 模式范例
	* `a)` 若关键字为a则吻合
	* `[[:plpha:]]` 若关键字为单个字母则吻合
	* `???)` 若关键字为三个字符则吻合
	* `*.txt)` 若关键字以.txt结尾则吻合
	* `*)` 与任何关键字吻合
* 可以使用竖线作为分隔符来组合多个模式，模式之间是"或"的条件关系

## CH32 位置参数
**访问命令行**
* shell提供了一组名为位置参数的变量，用于存储命令行中的关键字，这些变量分别命名为0~9
* 变量`$0`是所执行程序所在的路径名
* 变量`$#`可以给出命令行参数的数目
* 用shift处理大量的实参。每当执行一次shift命令时，变量`$2`的值就赋给变量`$1`，而`$3`的值就赋给`$2`，以此类推，变量`$#`的值同时减一
* 特殊的参数`*`和`@`
	* `$*` 可扩展为从1开始的位置参数列。当包含在双引号内时，扩展为双引号引用的由全部位置参数构成的字符串，每个位置参数以IFS shell变量的第一个字符(默认空格)间隔开
	* `$@` 可扩展为从1开始的位置参数列。当包含在双引号内时，将每个参数扩展为双引号引用的单独单词
	* `$@`保持了每个位置参数的完整性

## CH33 流控制FOR循环
**`for` 传统shell形式**
* 语法 
	```bash
	for variable [in words]; do
		commands
	done
	```
* for循环真正强大的功能在于创建字符列表的方式有很多种，可以使用花括号扩展方式，使用路径名扩展方式，使用命令形式
* for语句默认值是位置参数

**`for` C语言形式**
* 语法
	```bash
	for ((expression1; expression2; expression3)); do
		commands
	done
	```

## CH34 字符串和数字
**基本参数**
* 使用`${a}`相较于`$a`不容易混淆

**空变量扩展的管理**
* `${paramater:-word}` 如果paramater未被设定或者是空参数，则将其扩展为word的值，如果paramater非空，则扩展为paramater的值
* `${paramater:=word}` 如果paramater未被设定或者是空参数，则将其扩展为word的值，此外，word的值也将付给paramater。如果paramater非空，则扩展为paramater的值
* `${paramate:?word}` 如果paramater未设定或为空，这样扩展会导致脚本出错而退出，并且word的内容输出到标准错误。如果paramater非空，则扩展为paramater的值
* `${paramater:+word}` 如果paramater未设为空，将不产生任何扩展，若非空，word的值将替代paramater扩展，paramater本身不发生变化

**返回变量名的扩展**
* `${!prefix*}` `${!prefix@}` 该扩展返回当前以prefix开头的变量名

**字符串操作**
* `${#paramater}` 扩展为paramater内包含的字符串的长度。一般来说，参数paramater是个字符串，然而，如果参数是`@`或`*`，那么扩展结果就是位置参数的个数
* `${paramater:offset}`
* `${paramater:offset:legnth}` 这个扩展用来提取一部分包含在参数paramater中的字符串，扩展以offset字符开始，直到字符串末尾，除非length特别指定。如果offset的值为负，默认表示它从字符串末尾开始，而不是字符串开头，注意，负值前必须有一个空格，以防和之前一个扩展混淆，如果有length的话，不能小于0，如果参数是`@`，扩展的结果则是从offset开始 length为位置参数
* `${paramater#pattern}` 
* `${paramater##pattern}` 根据pattern定义，这些扩展祛除了包含在paramater中的字符串的主要部分。pattern是一个通配符模式，类似于那些用于路径名的扩展。两种形式的区别在于`#`形式去除最短匹配，而`##`形式去除最长匹配
* `${paramater%pattern}`
* `${paramater%%pattern}` 与上述`#`和`##`相同，除了一点 它们从参数包含的字符串末尾去除文本，而非字符串开头
* `${paramater/pattern/string}`
* `${paramater//pattern/string}`
* `${paramater/#pattern/string}`
* `${paramater/%pattern/string}` 如果文本被发现与pattern一致，就替换为string的内容，通常，只有第一个被替换。在`//`形势下，所有被替换，`/#`要求匹配出现在字符串开头 `/%`要求匹配出现在字符串末尾 `/string`可省略，就是删除匹配文本

**算数计算和扩展**
* 基本形式 `$((expression))` 其中expression是一个有效的算术表达式
* 数字进制 `27` 十进制 `051` 八进制 `0xff` 十六进制 `2#11101110` 二进制
* 普通运算符 `+` `-` `*` `/` `**` `%`
* 赋值 `=` `+=` `-=` `*=` `/=` `%=` `++` `--`
* 位操作 `~` `<<` `>>` `&` `|` `^` 
* 逻辑操作 `<=` `>=` `<` `>` `==` `!=` `&&` `||` `?:`

**`bc`一种任意精度计算语言**
* 无法直接用shell处理浮点数，使用一个专门的计算器程序bc
* `-q` 选项进制显示版权信息
* `bc`可以交互使用，可以通过标准输入传递一个脚本到`bc`，可以使用嵌入文档，嵌入字符串和管道传递脚本

## CH35 数组
。。。没了